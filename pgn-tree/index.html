<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>PGN tree visualizer</title>
	<link rel="stylesheet" href="../tools-shared.css" />
</head>

<body>
	<main class="app-shell">
		<section class="hero">
			<h1>PGN tree visualizer</h1>
			<p>Generate a detailed diagram of a PGN file.</p>
		</section>

		<section class="panel">
			<p id="status" class="status-line">Initializing Python and installing python-chess…</p>
			<div class="file-input-helper">
				<input type="file" id="pgn-input" accept=".pgn" class="hidden" />
				<button id="pick-pgn" class="primary-btn" disabled>Select PGN</button>
			</div>

			<h2 id="options-heading" class="options-heading hidden">Diagram options</h2>
			<div id="options" class="controls-grid hidden">
				<div class="control-item">
					<label for="side-select">Repertoire side</label>
					<select id="side-select">
						<option value="auto" selected>Auto (detect)</option>
						<option value="white">White</option>
						<option value="black">Black</option>
					</select>
				</div>
				<div class="control-item">
					<span class="checkbox-label">
						<input type="checkbox" id="piece-symbols" checked />
						Show chess piece symbols
					</span>
				</div>
			</div>
		</section>

		<section class="panel">
			<div class="panel-heading">
				<h2 id="diagram-title" class="hidden"></h2>
				<div class="download-actions">
					<button id="download-markdown-btn" class="ghost-btn hidden" disabled>Download markdown ⭳</button>
					<button id="download-image-btn" class="ghost-btn hidden" disabled>Download image ⭳</button>
				</div>
			</div>
			<div class="diagram-wrapper">
				<pre id="diagram" class="mermaid"></pre>
			</div>
			<div id="legend" class="legend-block"></div>
		</section>

		<footer>
			Powered by <a href="https://github.com/eduherminio/chess-toolbox" target="_blank" rel="noopener noreferrer">eduherminio/chess-toolbox</a>
			· Runs entirely in your browser
		</footer>
	</main>

	<script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
	<script type="module">
		import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
		mermaid.initialize({ startOnLoad: false, theme: "neutral" });

		let pyodide;
		const fileInput = document.getElementById("pgn-input");
		const pickButton = document.getElementById("pick-pgn");
		const optionsContainer = document.getElementById("options");
		const optionsHeading = document.getElementById("options-heading");
		const pieceSymbolsInput = document.getElementById("piece-symbols");
		const sideSelect = document.getElementById("side-select");
		const downloadMarkdownBtn = document.getElementById("download-markdown-btn");
		const downloadImageBtn = document.getElementById("download-image-btn");
		const diagramTitle = document.getElementById("diagram-title");
		const statusLine = document.getElementById("status");
		const legendDiv = document.getElementById("legend");
		let lastDiagramSvg = null;
		let currentImageName = "diagram.jpg";
		let lastLegendMarkdown = "";
		let lastMarkdown = "";
		let currentMarkdownName = "diagram.md";
		let currentDiagramTitle = "";
		fileInput.value = "";

		pickButton.addEventListener("click", () => fileInput.click());

		function showUploadControls() {
			pickButton.disabled = false;
			optionsContainer.classList.remove("hidden");
			if (optionsHeading) {
				optionsHeading.classList.remove("hidden");
			}
		}

		async function initPython() {
			pyodide = await loadPyodide({ fullStdLib: false });
			statusLine.textContent = "Installing python-chess…";
			await pyodide.loadPackage("micropip");
			await pyodide.runPythonAsync(`
				import micropip
				await micropip.install("chess")
			`);

			statusLine.textContent = "Loading PGN → Mermaid logic…";

			const commonCode = await fetch("../scripts/common.py").then(r => r.text());
			await pyodide.FS.writeFile("common.py", commonCode);

			const treeCode = await fetch("../scripts/pgn_tree.py").then(r => r.text());
			await pyodide.FS.writeFile("pgn_tree.py", treeCode);

			pyodide.runPython("from pgn_tree import parse_pgn, get_pgn_from_io");

			statusLine.textContent = "Ready. Select a PGN file from your repertoire.";
			showUploadControls();
		}

		initPython();

		fileInput.addEventListener("change", async (ev) => {
			const file = ev.target.files[0];
			if (!file) return;

			statusLine.textContent = "Parsing PGN and generating diagram…";
			downloadImageBtn.disabled = true;
			downloadImageBtn.classList.add("hidden");
			downloadMarkdownBtn.disabled = true;
			downloadMarkdownBtn.classList.add("hidden");
			diagramTitle.classList.add("hidden");
			diagramTitle.textContent = "";
			legendDiv.innerHTML = "";
			currentImageName = deriveJpgName(file.name || "diagram.pgn");
			currentMarkdownName = deriveMarkdownName(file.name || "diagram.pgn");
			lastMarkdown = "";
			lastLegendMarkdown = "";
			currentDiagramTitle = "";

			const pgnText = await file.text();
			const pieceSymbols = pieceSymbolsInput.checked;
			const sidePreference = sideSelect.value;

			const [diagram, legend, sideValue] = pyodide.runPython(`
		_game = get_pgn_from_io(${JSON.stringify(pgnText)})
		_diagram, _legend, _side, _origin = parse_pgn(
				_game,
				side_preference=${JSON.stringify(sidePreference)},
				piece_symbols=${pieceSymbols ? "True" : "False"}
		)
		(_diagram, _legend, _side.value)
			`);

			await renderDiagram(diagram);
			if (lastDiagramSvg) {
				downloadImageBtn.disabled = false;
				downloadImageBtn.classList.remove("hidden");
			}

			const fileLabel = file.name || "Diagram.pgn";
			currentDiagramTitle = fileLabel;
			if (sideValue) {
				const prettySide = sideValue.charAt(0).toUpperCase() + sideValue.slice(1);
				currentDiagramTitle = `${fileLabel} · ${prettySide} repertoire`;
				diagramTitle.textContent = currentDiagramTitle;
				diagramTitle.classList.remove("hidden");
			}
			lastLegendMarkdown = legend || "";
			lastMarkdown = buildDiagramMarkdown(currentDiagramTitle, diagram, lastLegendMarkdown);
			if (lastMarkdown) {
				downloadMarkdownBtn.disabled = false;
				downloadMarkdownBtn.classList.remove("hidden");
			}

			legendDiv.innerHTML = markedDownToHtml(legend);
			statusLine.textContent = "Done.";
			fileInput.value = "";
		});

		downloadImageBtn.addEventListener("click", async () => {
			if (!lastDiagramSvg) {
				return;
			}
			const blob = await svgToJpeg(lastDiagramSvg, 3);
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			link.href = url;
			link.download = currentImageName;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			URL.revokeObjectURL(url);
		});

		downloadMarkdownBtn.addEventListener("click", () => {
			if (!lastMarkdown) {
				return;
			}
			const blob = new Blob([lastMarkdown], { type: "text/markdown" });
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			link.href = url;
			link.download = currentMarkdownName;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			URL.revokeObjectURL(url);
		});

		async function svgToJpeg(svgText, scale = 1) {
			const viewBoxMatch = svgText.match(/viewBox="([\d.\s-]+)"/);
			const viewBox = viewBoxMatch ? viewBoxMatch[1].trim().split(/\s+/).map(Number) : null;
			return new Promise((resolve, reject) => {
				const svgBlob = new Blob([svgText], { type: "image/svg+xml" });
				const url = URL.createObjectURL(svgBlob);
				const img = new Image();
				img.onload = () => {
					const baseWidth = viewBox ? viewBox[2] : img.width;
					const baseHeight = viewBox ? viewBox[3] : img.height;
					const canvas = document.createElement("canvas");
					canvas.width = baseWidth * scale;
					canvas.height = baseHeight * scale;
					const ctx = canvas.getContext("2d");
					ctx.fillStyle = getCanvasBackgroundColor();
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					ctx.scale(scale, scale);
					ctx.drawImage(img, 0, 0, baseWidth, baseHeight);
					canvas.toBlob((blob) => {
						if (blob) {
							resolve(blob);
						} else {
							reject(new Error("Could not convert canvas to blob"));
						}
						URL.revokeObjectURL(url);
					}, "image/jpeg", 0.95);
				};
				img.onerror = (err) => {
					URL.revokeObjectURL(url);
					reject(err);
				};
				img.src = url;
			});
		}

		function deriveJpgName(originalName) {
			if (!originalName) {
				return "diagram.jpg";
			}
			const lastDot = originalName.lastIndexOf(".");
			const base = lastDot > 0 ? originalName.slice(0, lastDot) : originalName;
			const safeBase = base.trim() || "diagram";
			return `${safeBase}.jpg`;
		}

		function deriveMarkdownName(originalName) {
			if (!originalName) {
				return "diagram.md";
			}
			const lastDot = originalName.lastIndexOf(".");
			const base = lastDot > 0 ? originalName.slice(0, lastDot) : originalName;
			const safeBase = base.trim() || "diagram";
			return `${safeBase}_diagram.md`;
		}

		function buildDiagramMarkdown(title, diagramDefinition, legendMarkdown) {
			const parts = [];
			if (title && title.trim()) {
				parts.push(`# ${title.trim()}`);
			}
			if (diagramDefinition && diagramDefinition.trim()) {
				parts.push("```mermaid", diagramDefinition.trim(), "```");
			}
			if (legendMarkdown && legendMarkdown.trim()) {
				parts.push(legendMarkdown.trim());
			}
			const content = parts.join("\n\n").trim();
			return content ? `${content}\n` : "";
		}

		function getCanvasBackgroundColor() {
			const styles = getComputedStyle(document.documentElement);
			const value = styles.getPropertyValue("--canvas-bg").trim();
			return value || "#0b1121";
		}

		async function renderDiagram(definition) {
			if (!definition) {
				return;
			}
			const oldPre = document.getElementById("diagram");
			const newPre = document.createElement("pre");
			newPre.id = "diagram";
			newPre.className = "mermaid";
			const { svg } = await mermaid.render(`diagram_${Date.now()}`, definition, undefined, { theme: "neutral" });
			newPre.innerHTML = svg;
			lastDiagramSvg = svg;
			oldPre.replaceWith(newPre);
		}

		function markedDownToHtml(md) {
			md = md
				.replace(/\|\s*Color\s*\|\s*Meaning\s*\|\s*\n?/gi, "")
				.replace(/\|\s*-+\s*\|\s*-+\s*\|\s*\n?/g, "");

			let html = md
				.replace(/^## (.*)$/gm, "<h2>$1</h2>")
				.replace(/^# (.*)$/gm, "<h1>$1</h1>")
				.replace(/^\*\*(.+?)\*\*$/gm, "<h3>$1</h3>");

			html = html.replace(
				/((?:\|.*\|\n?)+)/g,
				(tableBlock) => {
					const rows = tableBlock.trim().split("\n").map(line => {
						const cells = line.split("|").slice(1, -1).map(c => `<td>${c.trim()}</td>`).join("");
						return `<tr>${cells}</tr>`;
					});
					return `<table>${rows.join("")}</table>`;
				}
			);

			html = html.replace(/(^|\n)([^<\n][^\n]*)/g, "<p>$2</p>");

			return html;
		}
	</script>
</body>

</html>
