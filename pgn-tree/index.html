<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>PGN tree visualizer</title>
	<link rel="stylesheet" href="../tools-shared.css" />
</head>

<body>
	<main class="app-shell">
		<section class="hero">
			<h1>PGN tree visualizer</h1>
			<p>Generate a detailed diagram of a PGN file.</p>
		</section>

		<section class="panel">
			<p id="status" class="status-line">Initializing Python and installing python-chess…</p>
			<div class="file-input-helper">
				<input type="file" id="pgn-input" accept=".pgn,.PGN,application/x-chess-pgn,text/plain" class="hidden" />
				<button id="pick-pgn" class="primary-btn" disabled>Select PGN</button>
			</div>

			<h2 id="options-heading" class="options-heading hidden">Diagram options</h2>
			<div id="options" class="controls-grid hidden">
				<div class="control-item">
					<label for="side-select">Repertoire side</label>
					<select id="side-select">
						<option value="auto" selected>Auto (detect)</option>
						<option value="white">White</option>
						<option value="black">Black</option>
					</select>
				</div>
				<div class="control-item">
					<span class="checkbox-label">
						<input type="checkbox" id="piece-symbols" checked />
						Show chess piece symbols
					</span>
				</div>
			</div>
		</section>

		<section class="panel">
			<div class="panel-heading">
				<h2 id="diagram-title" class="hidden"></h2>
				<div class="download-actions">
					<button id="diagram-theme-btn" class="ghost-btn hidden" disabled>Light diagram background ☀</button>
					<button id="download-all-images-btn" class="ghost-btn hidden" disabled>Download all images ⭳</button>
					<button id="download-all-markdown-btn" class="ghost-btn hidden" disabled>Download all markdown ⭳</button>
				</div>
			</div>
			<div id="diagram-collection" class="sections-stack"></div>
		</section>

		<footer>
			Powered by <a href="https://github.com/eduherminio/chess-toolbox" target="_blank" rel="noopener noreferrer">eduherminio/chess-toolbox</a>
			· Runs entirely in your browser
		</footer>
	</main>

	<script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
	<script type="module">
		import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
		mermaid.initialize({ startOnLoad: false, theme: "neutral" });

		let pyodide;
		const fileInput = document.getElementById("pgn-input");
		const pickButton = document.getElementById("pick-pgn");
		const optionsContainer = document.getElementById("options");
		const optionsHeading = document.getElementById("options-heading");
		const pieceSymbolsInput = document.getElementById("piece-symbols");
		const sideSelect = document.getElementById("side-select");
		const downloadAllImagesBtn = document.getElementById("download-all-images-btn");
		const downloadAllMarkdownBtn = document.getElementById("download-all-markdown-btn");
		const diagramThemeBtn = document.getElementById("diagram-theme-btn");
		const diagramTitle = document.getElementById("diagram-title");
		const statusLine = document.getElementById("status");
		const diagramCollection = document.getElementById("diagram-collection");
		let renderedDiagrams = [];
		let diagramCounter = 0;
		const DiagramThemes = Object.freeze({ DARK: "dark", LIGHT: "light" });
		const DiagramThemeConfig = Object.freeze({
			[DiagramThemes.DARK]: { background: "#0b1121" },
			[DiagramThemes.LIGHT]: { background: "#ffffff" },
		});
		let currentDiagramTheme = DiagramThemes.DARK;
		fileInput.value = "";
		applyDiagramTheme(DiagramThemes.DARK);

		pickButton.addEventListener("click", () => fileInput.click());

		function showUploadControls() {
			pickButton.disabled = false;
			optionsContainer.classList.remove("hidden");
			if (optionsHeading) {
				optionsHeading.classList.remove("hidden");
			}
		}

		async function initPython() {
			pyodide = await loadPyodide({ fullStdLib: false });
			statusLine.textContent = "Installing python-chess…";
			await pyodide.loadPackage("micropip");
			await pyodide.runPythonAsync(`
				import micropip
				await micropip.install("chess")
			`);

			statusLine.textContent = "Loading PGN → Mermaid logic…";

			const commonCode = await fetch("../scripts/common.py").then(r => r.text());
			await pyodide.FS.writeFile("common.py", commonCode);

			const treeCode = await fetch("../scripts/pgn_tree.py").then(r => r.text());
			await pyodide.FS.writeFile("pgn_tree.py", treeCode);

			pyodide.runPython("from pgn_tree import parse_pgn_collection");

			statusLine.textContent = "Ready. Select a PGN file from your repertoire.";
			showUploadControls();
		}

		initPython();

		fileInput.addEventListener("change", async (ev) => {
			const file = ev.target.files[0];
			if (!file) return;

			statusLine.textContent = "Parsing PGN games and generating diagrams…";
			clearRenderedDiagrams();
			const pgnText = await file.text();
			const pieceSymbols = pieceSymbolsInput.checked;
			const sidePreference = sideSelect.value;

			try {
				const pyResult = pyodide.runPython(`
from pgn_tree import parse_pgn_collection
parse_pgn_collection(
	${JSON.stringify(pgnText)},
	side_preference=${JSON.stringify(sidePreference)},
	piece_symbols=${pieceSymbols ? "True" : "False"}
)
				`);
				const pyEntries = pyResult.toJs({
					deep: true,
					dict_converter: (pyDict) => Object.fromEntries(pyDict),
				});
				const parsedEntries = Array.isArray(pyEntries) ? pyEntries : Array.from(pyEntries || []);
				await renderDiagramCollection(parsedEntries, file.name || "Diagram.pgn");
				if (pyEntries && typeof pyEntries.destroy === "function") {
					pyEntries.destroy();
				}
				if (pyResult && typeof pyResult.destroy === "function") {
					pyResult.destroy();
				}
				statusLine.textContent = "Done.";
			} catch (err) {
				console.error(err);
				statusLine.textContent = `Something went wrong: ${err.message}`;
			} finally {
				fileInput.value = "";
			}
		});

		if (downloadAllImagesBtn) {
			downloadAllImagesBtn.addEventListener("click", async () => {
				if (!renderedDiagrams.length) {
					return;
				}
				downloadAllImagesBtn.disabled = true;
				try {
					await downloadAllDiagramImages();
				} finally {
					downloadAllImagesBtn.disabled = false;
				}
			});
		}

		if (downloadAllMarkdownBtn) {
			downloadAllMarkdownBtn.addEventListener("click", () => {
				if (!renderedDiagrams.length) {
					return;
				}
				downloadAllMarkdownBtn.disabled = true;
				try {
					downloadAllDiagramMarkdowns();
				} finally {
					downloadAllMarkdownBtn.disabled = false;
				}
			});
		}

		diagramThemeBtn.addEventListener("click", () => {
			const nextTheme = currentDiagramTheme === DiagramThemes.DARK ? DiagramThemes.LIGHT : DiagramThemes.DARK;
			applyDiagramTheme(nextTheme);
		});

		async function svgToJpeg(svgText, scale = 1) {
			const viewBoxMatch = svgText.match(/viewBox="([\d.\s-]+)"/);
			const viewBox = viewBoxMatch ? viewBoxMatch[1].trim().split(/\s+/).map(Number) : null;
			return new Promise((resolve, reject) => {
				const img = new Image();
				img.onload = () => {
					const baseWidth = viewBox ? viewBox[2] : img.width;
					const baseHeight = viewBox ? viewBox[3] : img.height;
					const canvas = document.createElement("canvas");
					canvas.width = baseWidth * scale;
					canvas.height = baseHeight * scale;
					const ctx = canvas.getContext("2d");
					ctx.fillStyle = getCanvasBackgroundColor();
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					ctx.scale(scale, scale);
					ctx.drawImage(img, 0, 0, baseWidth, baseHeight);
					canvas.toBlob((blob) => {
						if (blob) {
							resolve(blob);
						} else {
							reject(new Error("Could not convert canvas to blob"));
						}
					}, "image/jpeg", 0.95);
				};
				img.onerror = (err) => {
					reject(err);
				};
				img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgText);
			});
		}

		function getSafeBaseName(originalName) {
			if (!originalName) {
				return "diagram";
			}
			const lastDot = originalName.lastIndexOf(".");
			const base = lastDot > 0 ? originalName.slice(0, lastDot) : originalName;
			const safeBase = base.trim() || "diagram";
			return safeBase.replace(/[^a-z0-9]+/gi, "_");
		}

		function deriveJpgName(originalName, slug) {
			const base = getSafeBaseName(originalName);
			const suffix = slug ? `_${slug}` : "";
			return `${base}${suffix}.jpg`;
		}

		function deriveMarkdownName(originalName, slug) {
			const base = getSafeBaseName(originalName);
			const suffix = slug ? `_${slug}` : "";
			return `${base}${suffix}_diagram.md`;
		}

		function clearRenderedDiagrams() {
			renderedDiagrams = [];
			diagramCounter = 0;
			diagramCollection.innerHTML = "";
			diagramTitle.textContent = "";
			diagramTitle.classList.add("hidden");
			diagramThemeBtn.disabled = true;
			diagramThemeBtn.classList.add("hidden");
			if (downloadAllImagesBtn) {
				downloadAllImagesBtn.disabled = true;
				downloadAllImagesBtn.classList.add("hidden");
			}
			if (downloadAllMarkdownBtn) {
				downloadAllMarkdownBtn.disabled = true;
				downloadAllMarkdownBtn.classList.add("hidden");
			}
		}

		async function renderDiagramCollection(entries, originalName) {
			if (!Array.isArray(entries) || !entries.length) {
				statusLine.textContent = "No games were found in that PGN.";
				return;
			}
			const fileLabel = originalName || "Diagram.pgn";
			const isSingleDiagram = entries.length === 1;
			if (isSingleDiagram) {
				diagramTitle.textContent = fileLabel;
			} else {
				diagramTitle.textContent = `${fileLabel} (${entries.length} games)`;
			}
			diagramTitle.classList.remove("hidden");
			diagramThemeBtn.disabled = false;
			diagramThemeBtn.classList.remove("hidden");
			if (downloadAllImagesBtn) {
				if (isSingleDiagram) {
					downloadAllImagesBtn.disabled = true;
					downloadAllImagesBtn.classList.add("hidden");
				} else {
					downloadAllImagesBtn.disabled = false;
					downloadAllImagesBtn.classList.remove("hidden");
				}
			}
			if (downloadAllMarkdownBtn) {
				if (isSingleDiagram) {
					downloadAllMarkdownBtn.disabled = true;
					downloadAllMarkdownBtn.classList.add("hidden");
				} else {
					downloadAllMarkdownBtn.disabled = false;
					downloadAllMarkdownBtn.classList.remove("hidden");
				}
			}

			for (let idx = 0; idx < entries.length; idx += 1) {
				// eslint-disable-next-line no-await-in-loop
				await renderDiagramCard(entries[idx], idx, fileLabel, isSingleDiagram);
			}
		}

		function slugifyLabel(value, idx) {
			const normalized = (value || "").toString().toLowerCase().trim();
			const slug = normalized.replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
			return slug || `game_${idx + 1}`;
		}

		async function renderDiagramCard(entry, idx, originalName, suppressHeading = false) {
			const entryData = entry || {};
			const safeTitle = (entryData.title && entryData.title.trim()) || `Game ${idx + 1}`;
			const slug = entryData.slug ? entryData.slug.trim() : slugifyLabel(safeTitle, idx);
			const section = document.createElement("section");
			section.className = "section-card";
			diagramCollection.appendChild(section);

			if (!suppressHeading) {
				const heading = document.createElement("h3");
				heading.textContent = safeTitle;
				section.appendChild(heading);
			}

			const sideLabel = formatSideLabel(entryData.side);
			const originLabel = entryData.origin || "starting position";
			const subtitle = document.createElement("h3");
			subtitle.textContent = sideLabel
				? `${sideLabel} repertoire from ${originLabel}`
				: `Origin: ${originLabel}`;
			section.appendChild(subtitle);

			const actions = document.createElement("div");
			actions.className = "download-actions";
			section.appendChild(actions);

			diagramCounter += 1;
			const entryId = `diagram-${diagramCounter}`;
			const downloadImageButton = document.createElement("button");
			downloadImageButton.className = "ghost-btn";
			downloadImageButton.textContent = "Download image ⭳";
			actions.appendChild(downloadImageButton);

			const downloadMarkdownButton = document.createElement("button");
			downloadMarkdownButton.className = "ghost-btn";
			downloadMarkdownButton.textContent = "Download markdown ⭳";
			actions.appendChild(downloadMarkdownButton);

			const diagramWrapper = document.createElement("div");
			diagramWrapper.className = "diagram-wrapper";
			section.appendChild(diagramWrapper);

			const pre = document.createElement("pre");
			pre.className = "mermaid";
			pre.id = entryId;
			diagramWrapper.appendChild(pre);

			const legendMarkdown = (entryData.legend || "").trim();
			if (legendMarkdown) {
				const legendBlock = document.createElement("div");
				legendBlock.className = "legend-block";
				legendBlock.innerHTML = markedDownToHtml(legendMarkdown);
				section.appendChild(legendBlock);
			}

			const definition = entryData.diagram || "flowchart TD\nA[No moves]";
			const svg = await renderMermaidDefinition(entryId, definition);

			const cardTitle = buildCardTitle(safeTitle, sideLabel, originLabel);
			const entryState = {
				id: entryId,
				title: safeTitle,
				slug,
				imageName: deriveJpgName(originalName, slug),
				markdownName: deriveMarkdownName(originalName, slug),
				diagramDefinition: definition,
				legendMarkdown,
				svg,
				markdown: buildDiagramMarkdown(cardTitle, definition, legendMarkdown),
			};
			renderedDiagrams.push(entryState);

			downloadImageButton.addEventListener("click", async () => {
				await downloadDiagramImage(entryId);
			});
			downloadMarkdownButton.addEventListener("click", () => downloadDiagramMarkdown(entryId));
		}

		function formatSideLabel(sideValue) {
			if (!sideValue) {
				return "";
			}
			const normalized = sideValue.toString().trim().toLowerCase();
			if (!normalized) {
				return "";
			}
			return normalized.charAt(0).toUpperCase() + normalized.slice(1);
		}

		function buildCardTitle(gameTitle, sideLabel, originLabel) {
			if (sideLabel && originLabel) {
				return `${gameTitle} - ${sideLabel} repertoire from ${originLabel}`;
			}
			if (sideLabel) {
				return `${gameTitle} - ${sideLabel} repertoire`;
			}
			return gameTitle;
		}

		function findRenderedDiagram(entryId) {
			return renderedDiagrams.find((entry) => entry.id === entryId);
		}

		async function downloadDiagramImage(entryId) {
			const entry = findRenderedDiagram(entryId);
			if (!entry || !entry.svg) {
				return;
			}
			const blob = await svgToJpeg(entry.svg, 3);
			triggerBlobDownload(blob, entry.imageName);
		}

		function downloadDiagramMarkdown(entryId) {
			const entry = findRenderedDiagram(entryId);
			if (!entry || !entry.markdown) {
				return;
			}
			const themedMarkdown = applyDiagramThemeToMarkdown(entry.markdown, currentDiagramTheme);
			triggerTextDownload(themedMarkdown, entry.markdownName);
		}

		async function downloadAllDiagramImages() {
			for (const entry of renderedDiagrams) {
				if (!entry || !entry.id) {
					continue;
				}
				// eslint-disable-next-line no-await-in-loop
				await downloadDiagramImage(entry.id);
			}
		}

		function downloadAllDiagramMarkdowns() {
			for (const entry of renderedDiagrams) {
				if (!entry || !entry.id) {
					continue;
				}
				downloadDiagramMarkdown(entry.id);
			}
		}

		function triggerBlobDownload(blob, filename) {
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			link.href = url;
			link.download = filename;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			URL.revokeObjectURL(url);
		}

		function triggerTextDownload(text, filename) {
			const blob = new Blob([text], { type: "text/markdown" });
			triggerBlobDownload(blob, filename);
		}

		function buildDiagramMarkdown(title, diagramDefinition, legendMarkdown) {
			const parts = [];
			if (title && title.trim()) {
				parts.push(`# ${title.trim()}`);
			}
			if (diagramDefinition && diagramDefinition.trim()) {
				parts.push("```mermaid", diagramDefinition.trim(), "```");
			}
			if (legendMarkdown && legendMarkdown.trim()) {
				parts.push(legendMarkdown.trim());
			}
			parts.push("> Source: eduherminio/chess-toolbox");
			const content = parts.join("\n\n").trim();
			return content ? `${content}\n` : "";
		}

		function getCanvasBackgroundColor() {
			const host = document.body || document.documentElement;
			const styles = getComputedStyle(host);
			const value = styles.getPropertyValue("--canvas-bg").trim();
			return value || "#0b1121";
		}

		async function renderMermaidDefinition(elementId, definition) {
			const target = document.getElementById(elementId);
			if (!target || !definition) {
				return "";
			}
			const { svg } = await mermaid.render(`diagram_${elementId}_${Date.now()}`, definition, undefined, { theme: "neutral" });
			target.innerHTML = svg;
			return svg;
		}

		function markedDownToHtml(md) {
			if (!md) {
				return "";
			}
			let normalized = md
				.replace(/\|\s*Color\s*\|\s*Meaning\s*\|\s*\n?/gi, "")
				.replace(/\|\s*-+\s*\|\s*-+\s*\|\s*\n?/g, "");

			normalized = normalized
				.replace(/^## (.*)$/gm, "<h2>$1</h2>")
				.replace(/^# (.*)$/gm, "<h1>$1</h1>")
				.replace(/^\*\*(.+?)\*\*$/gm, "<h3>$1</h3>");

			normalized = normalized.replace(
				/((?:\|.*\|\n?)+)/g,
				(tableBlock) => {
					const rows = tableBlock.trim().split("\n").map(line => {
						const cells = line.split("|").slice(1, -1).map(c => `<td>${c.trim()}</td>`).join("");
						return `<tr>${cells}</tr>`;
					});
					return `<table>${rows.join("")}</table>`;
				}
			);

			return normalized.replace(/(^|\n)([^<\n][^\n]*)/g, "<p>$2</p>");
		}

		function applyDiagramTheme(theme) {
			const normalizedTheme = theme === DiagramThemes.LIGHT ? DiagramThemes.LIGHT : DiagramThemes.DARK;
			currentDiagramTheme = normalizedTheme;
			if (document.body) {
				document.body.dataset.diagramTheme = normalizedTheme;
			}
			if (diagramThemeBtn) {
				diagramThemeBtn.textContent = normalizedTheme === DiagramThemes.LIGHT
					? "Dark theme ◐"
					: "Light theme ☀";
			}
		}

		function applyDiagramThemeToMarkdown(markdown, theme) {
			if (!markdown) {
				return markdown;
			}
			const initLine = buildMermaidInitDirective(theme);
			return markdown.replace(/```mermaid\s*\n([\s\S]*?)```/g, (match, inner) => {
				const sanitized = inner
					.replace(/^\s*%%\{init:[\s\S]*?%%\s*/i, "")
					.replace(/^\n+/, "");
				const body = sanitized.replace(/\s+$/, "");
				const newline = body.endsWith("\n") ? "" : "\n";
				return "```mermaid\n" + initLine + "\n" + body + newline + "```\n";
			});
		}

		function buildMermaidInitDirective(theme) {
			const config = DiagramThemeConfig[theme] || DiagramThemeConfig[DiagramThemes.DARK];
			const payload = {
				theme: "neutral",
				themeVariables: {
					background: config.background,
				},
			};
			return `%%{init: ${JSON.stringify(payload)}}%%`;
		}
	</script>
</body>

</html>
