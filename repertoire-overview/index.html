<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>Repertoire visualizer</title>
	<link rel="stylesheet" href="../tools-shared.css" />
</head>

<body>
	<main class="app-shell">
		<section class="hero">
			<h1>Repertoire visualizer</h1>
			<p>Get an overview of your repertoire.</p>
		</section>

		<section class="panel">
			<p id="status" class="status-line">Initializing Python and installing python-chess…</p>
			<div class="file-input-helper">
				<input type="file" id="pgn-folder" accept=".pgn,.PGN,application/x-chess-pgn,text/plain" multiple class="hidden" />
				<input type="file" id="pgn-files" accept=".pgn,.PGN,application/x-chess-pgn,text/plain" multiple class="hidden" />
				<div class="picker-buttons">
					<button id="folder-picker" class="ghost-btn" disabled>PGN folder</button>
					<button id="file-picker" class="ghost-btn" disabled>PGN files</button>
				</div>
			</div>

			<h2 id="options-heading" class="options-heading hidden">Diagram options</h2>
			<div id="options" class="controls-grid hidden">
				<div class="control-item">
					<label for="side-select">Repertoire side</label>
					<select id="side-select">
						<option value="auto" selected>Auto (detect)</option>
						<option value="white">White</option>
						<option value="black">Black</option>
					</select>
				</div>
				<div class="control-item">
					<label for="max-ply">Max ply depth</label>
					<input type="number" id="max-ply" min="0" value="4" />
				</div>
				<div class="control-item">
					<span class="checkbox-label">
						<input type="checkbox" id="piece-symbols" checked />
						Show chess piece symbols
					</span>
				</div>
			</div>
		</section>

		<section class="panel">
			<div class="panel-heading">
				<h2 id="diagram-title" class="hidden"></h2>
				<div class="download-actions">
					<button id="diagram-theme-btn" class="ghost-btn hidden" disabled>Light diagram background ☀</button>
					<button id="download-btn" class="ghost-btn hidden" disabled>Download markdown ⭳</button>
					<button id="download-images-btn" class="ghost-btn hidden" disabled>Download images ⭳</button>
				</div>
			</div>
			<div id="sections-container" class="sections-stack"></div>
			<div id="legend" class="legend-block"></div>
		</section>

		<footer>
			Powered by <a href="https://github.com/eduherminio/chess-toolbox" target="_blank" rel="noopener noreferrer">eduherminio/chess-toolbox</a>
			· Runs entirely in your browser
		</footer>
	</main>

	<!-- Pyodide -->
	<script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>

	<!-- Mermaid -->
	<script type="module">
		import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
		mermaid.initialize({ startOnLoad: false, theme: "neutral" });

		let pyodide;
		const folderInput = document.getElementById("pgn-folder");
		const filesInput = document.getElementById("pgn-files");
		const folderPicker = document.getElementById("folder-picker");
		const filePicker = document.getElementById("file-picker");
		const optionsContainer = document.getElementById("options");
		const optionsHeading = document.getElementById("options-heading");
		const sideSelect = document.getElementById("side-select");
		const pieceSymbolsInput = document.getElementById("piece-symbols");
		const maxPlyInput = document.getElementById("max-ply");
		const downloadBtn = document.getElementById("download-btn");
		const downloadImagesBtn = document.getElementById("download-images-btn");
		const diagramThemeBtn = document.getElementById("diagram-theme-btn");
		const diagramTitle = document.getElementById("diagram-title");
		const sectionsContainer = document.getElementById("sections-container");
		const legendDiv = document.getElementById("legend");
		const statusEl = document.getElementById("status");
		const UPLOAD_BASE = "/tmp/repertoire_uploads";
		const diagramDefinitions = new Map();
		const textEncoder = new TextEncoder();
		const textDecoder = new TextDecoder("utf-8");
		const svgSerializer = new XMLSerializer();
		const IMAGE_EXPORT_SCALE = 3;
		const DiagramThemes = Object.freeze({ DARK: "dark", LIGHT: "light" });
		const DiagramThemeConfig = Object.freeze({
			[DiagramThemes.DARK]: { background: "#0b1121" },
			[DiagramThemes.LIGHT]: { background: "#ffffff" },
		});
		const supportsDirectoryUploads = "webkitdirectory" in folderInput;
		const readyStatusMessages = Object.freeze({
			directory: "Ready. Choose a PGN folder or multiple PGN files.",
			filesOnly: "Ready. Select one or more PGN files (folder uploads aren't supported in this browser).",
		});
		let lastMarkdown = "";
		let currentDownloadName = "PGN_variations_overview.md";
		let currentDiagramTheme = DiagramThemes.DARK;

		configureFolderInputCapabilities();
		syncPickerVisibilityWithCapabilities();
		folderInput.value = "";
		applyDiagramTheme(DiagramThemes.DARK);

		function configureFolderInputCapabilities() {
			folderInput.multiple = true;
			if (supportsDirectoryUploads) {
				folderInput.setAttribute("webkitdirectory", "");
			} else {
				folderInput.removeAttribute("webkitdirectory");
			}
		}

		function setReadyStatusMessage() {
			statusEl.textContent = supportsDirectoryUploads
				? readyStatusMessages.directory
				: readyStatusMessages.filesOnly;
		}

		function getEmptySelectionMessage(selectionType) {
			if (selectionType === "folder" && supportsDirectoryUploads) {
				return "Select a folder that contains at least one .pgn file.";
			}
			return supportsDirectoryUploads
				? "Select one or more .pgn files."
				: "Select one or more .pgn files (folder uploads aren't supported in this browser).";
		}

		function showUploadControls() {
			syncPickerVisibilityWithCapabilities();
			folderPicker.disabled = !supportsDirectoryUploads;
			filePicker.disabled = false;
			filePicker.classList.remove("hidden");
			if (optionsHeading) {
				optionsHeading.classList.remove("hidden");
			}
			optionsContainer.classList.remove("hidden");
		}

		function syncPickerVisibilityWithCapabilities() {
			if (supportsDirectoryUploads) {
				folderPicker.classList.remove("hidden");
			} else {
				folderPicker.classList.add("hidden");
			}
		}

		async function initPython() {
			pyodide = await loadPyodide({ fullStdLib: false });

			statusEl.textContent = "Installing python-chess…";
			await pyodide.loadPackage("micropip");
			await pyodide.runPythonAsync(`
				import micropip
				await micropip.install("chess")
			`);

			statusEl.textContent = "Loading repertoire overview logic…";

			const commonCode = await fetch("../scripts/common.py").then(r => r.text());
			await pyodide.FS.writeFile("common.py", commonCode);

			const overviewCode = await fetch("../scripts/repertoire_overview.py").then(r => r.text());
			await pyodide.FS.writeFile("repertoire_overview.py", overviewCode);

			pyodide.runPython("from repertoire_overview import main");

			setReadyStatusMessage();
			showUploadControls();
		}

		initPython();

		folderPicker.addEventListener("click", () => {
			if (!supportsDirectoryUploads) {
				return;
			}
			folderInput.click();
		});

		filePicker.addEventListener("click", () => {
			filesInput.click();
		});

		folderInput.addEventListener("change", async (event) => {
			await handlePgnSelection(Array.from(event.target.files || []), "folder", folderInput);
		});

		filesInput.addEventListener("change", async (event) => {
			await handlePgnSelection(Array.from(event.target.files || []), "files", filesInput);
		});

		async function handlePgnSelection(files, selectionType, inputEl) {
			const pgnFiles = files.filter((file) => file.name.toLowerCase().endsWith(".pgn"));
			if (!pgnFiles.length) {
				statusEl.textContent = getEmptySelectionMessage(selectionType);
				if (inputEl) {
					inputEl.value = "";
				}
				return;
			}

			resetDiagramOutputs();
			statusEl.textContent = "Copying PGNs into the embedded filesystem…";

			try {
				const stagingInfo = await stageFilesInPyodide(pgnFiles);
				const sidePreference = sideSelect.value;
				const usePieceSymbols = pieceSymbolsInput.checked;
				const maxPlyValue = parseMaxPly(maxPlyInput.value);
				currentDownloadName = deriveMarkdownName(stagingInfo.displayName);

				statusEl.textContent = "Inferring repertoire overview…";
				const outputPath = `${stagingInfo.rootPath}/PGN_variations_overview.md`;
				const args = buildCliArgs(
					stagingInfo.rootPath,
					outputPath,
					sidePreference,
					maxPlyValue,
					usePieceSymbols,
				);
				const exitCode = await pyodide.runPythonAsync(`
	from repertoire_overview import main
	main(argv=${JSON.stringify(args)})
				`);

				if (exitCode !== 0) {
					throw new Error(`Python exited with code ${exitCode}`);
				}

				const markdownData = pyodide.FS.readFile(outputPath);
				const markdown = typeof markdownData === "string" ? markdownData : textDecoder.decode(markdownData);
				lastMarkdown = markdown;
				const hasDiagrams = await renderOverview(markdown, stagingInfo.displayName);
				statusEl.textContent = "Done.";
				downloadBtn.disabled = false;
				downloadBtn.classList.remove("hidden");
				if (hasDiagrams) {
					downloadImagesBtn.disabled = false;
					downloadImagesBtn.classList.remove("hidden");
					diagramThemeBtn.disabled = false;
					diagramThemeBtn.classList.remove("hidden");
				}
			} catch (err) {
				console.error(err);
				statusEl.textContent = `Something went wrong: ${err.message}`;
			} finally {
				if (inputEl) {
					inputEl.value = "";
				}
			}
		}

		function resetDiagramOutputs() {
			downloadBtn.disabled = true;
			downloadBtn.classList.add("hidden");
			downloadImagesBtn.disabled = true;
			downloadImagesBtn.classList.add("hidden");
			diagramThemeBtn.disabled = true;
			diagramThemeBtn.classList.add("hidden");
			diagramTitle.classList.add("hidden");
			sectionsContainer.innerHTML = "";
			legendDiv.innerHTML = "";
		}

		downloadBtn.addEventListener("click", () => {
			if (!lastMarkdown) {
				return;
			}
			const themedMarkdown = applyDiagramThemeToMarkdown(lastMarkdown, currentDiagramTheme);
			const blob = new Blob([themedMarkdown], { type: "text/markdown" });
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			link.href = url;
			link.download = currentDownloadName;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			URL.revokeObjectURL(url);
		});

		downloadImagesBtn.addEventListener("click", async () => {
			if (!diagramDefinitions.size) {
				return;
			}
			downloadImagesBtn.disabled = true;
			const previousStatus = statusEl.textContent;
			statusEl.textContent = "Building diagram images…";
			try {
				await downloadAllDiagramImages();
				statusEl.textContent = "Diagram images downloaded.";
			} catch (err) {
				console.error(err);
				statusEl.textContent = `Failed to export diagrams: ${err.message}`;
			} finally {
				downloadImagesBtn.disabled = false;
				setTimeout(() => {
					statusEl.textContent = previousStatus;
				}, 4000);
			}
		});

		diagramThemeBtn.addEventListener("click", () => {
			const nextTheme = currentDiagramTheme === DiagramThemes.DARK ? DiagramThemes.LIGHT : DiagramThemes.DARK;
			applyDiagramTheme(nextTheme);
		});

		async function stageFilesInPyodide(files) {
			const sessionDir = `${UPLOAD_BASE}/session_${Date.now()}`;
			try {
				pyodide.FS.mkdirTree(sessionDir);
			} catch (err) {
				if (err.code !== "EEXIST") {
					throw err;
				}
			}

			const hasNestedStructure = files.some((file) => file.webkitRelativePath && file.webkitRelativePath.length > 0);
			let written = 0;

			if (hasNestedStructure) {
				let topLevelFolder = null;
				for (const file of files) {
					const relativeParts = normalizeRelativePath(file);
					if (!relativeParts.length) {
						continue;
					}
					if (!topLevelFolder) {
						topLevelFolder = relativeParts[0];
					}
					const filePath = `${sessionDir}/${relativeParts.join("/")}`;
					const dirPath = filePath.slice(0, filePath.lastIndexOf("/"));
					if (dirPath) {
						pyodide.FS.mkdirTree(dirPath);
					}
					const content = await file.text();
					pyodide.FS.writeFile(filePath, textEncoder.encode(content));
					written += 1;
				}
				if (!written) {
					throw new Error("No PGN files could be copied");
				}
				const safeFolder = topLevelFolder || "repertoire";
				return { rootPath: `${sessionDir}/${safeFolder}`, displayName: safeFolder };
			}

			const fallbackRoot = `${sessionDir}/pgn_upload`;
			pyodide.FS.mkdirTree(fallbackRoot);
			for (const file of files) {
				const rawName = (file.name || "").trim();
				if (!rawName) {
					continue;
				}
				const safeName = rawName.replace(/[\\/]+/g, "_");
				const filePath = `${fallbackRoot}/${safeName}`;
				const content = await file.text();
				pyodide.FS.writeFile(filePath, textEncoder.encode(content));
				written += 1;
			}
			if (!written) {
				throw new Error("No PGN files could be copied");
			}
			return { rootPath: fallbackRoot, displayName: deriveFallbackDisplayName(files) };
		}

		function normalizeRelativePath(file) {
			const relative = file.webkitRelativePath && file.webkitRelativePath.length > 0
				? file.webkitRelativePath
				: file.name;
			return relative.split("/").filter(Boolean);
		}

		function deriveFallbackDisplayName(files) {
			if (!files.length) {
				return "pgn_files";
			}
			const candidate = (files[0].name || "")
				.replace(/\.[^.]+$/i, "")
				.trim();
			return candidate || "pgn_files";
		}

		function buildCliArgs(rootPath, outputPath, side, maxPly, pieceSymbols) {
			const args = ["--pgn-root", rootPath, "--output", outputPath, "--side", side];
			if (typeof maxPly === "number" && Number.isFinite(maxPly) && maxPly >= 0) {
				args.push("--max-ply", String(maxPly));
			}
			if (pieceSymbols) {
				args.push("--piece-symbols");
			}
			return args;
		}

		function parseMaxPly(value) {
			const parsed = Number.parseInt(String(value), 10);
			if (Number.isNaN(parsed) || parsed < 0) {
				return 4;
			}
			return parsed;
		}

		function deriveMarkdownName(folderName) {
			const safe = (folderName || "overview").trim() || "overview";
			return `${safe}_PGN_variations_overview.md`;
		}

		async function renderOverview(markdown, folderLabel) {
			const parsed = parseOverviewMarkdown(markdown);
			diagramTitle.textContent = parsed.title || `Repertoire overview (${folderLabel})`;
			diagramTitle.classList.remove("hidden");
			sectionsContainer.innerHTML = "";
			diagramDefinitions.clear();

			parsed.sections.forEach((section, idx) => {
				const sectionEl = document.createElement("section");
				sectionEl.className = "section-card";

				const heading = document.createElement("h3");
				heading.textContent = section.title;
				sectionEl.appendChild(heading);

				const diagramWrapper = document.createElement("div");
				diagramWrapper.className = "diagram-wrapper";
				const pre = document.createElement("pre");
				pre.className = "mermaid";
				pre.id = `diagram-section-${idx}`;
				diagramWrapper.appendChild(pre);
				sectionEl.appendChild(diagramWrapper);
				diagramDefinitions.set(pre.id, { definition: section.diagram, title: section.title });

				if (section.tableMarkdown) {
					const tableHeading = document.createElement("h4");
					tableHeading.textContent = "Terminal references";
					sectionEl.appendChild(tableHeading);
					const tableWrapper = document.createElement("div");
					tableWrapper.innerHTML = tableMarkdownToHtml(section.tableMarkdown);
					sectionEl.appendChild(tableWrapper);
				}

				sectionsContainer.appendChild(sectionEl);
			});

			legendDiv.innerHTML = parsed.footer ? `<p>${escapeHtml(parsed.footer)}</p>` : "";
			await renderAllDiagrams();
			return diagramDefinitions.size > 0;
		}

		function parseOverviewMarkdown(markdown) {
			const lines = markdown.split(/\r?\n/);
			const sections = [];
			let title = "";
			let idx = 0;
			let footer = "";

			while (idx < lines.length) {
				const line = lines[idx];
				if (!title && line.startsWith("# ")) {
					title = line.slice(2).trim();
					idx += 1;
					continue;
				}
				if (line.startsWith("> ")) {
					footer = line.replace(/^>\s*/, "").trim();
				}
				if (line.startsWith("## ")) {
					const sectionTitle = line.slice(3).trim();
					idx += 1;
					while (idx < lines.length && !lines[idx].trim()) {
						idx += 1;
					}
					let diagramDef = "";
					if (lines[idx] === "```mermaid") {
						idx += 1;
						const diagramLines = [];
						while (idx < lines.length && lines[idx] !== "```") {
							diagramLines.push(lines[idx]);
							idx += 1;
						}
						diagramDef = diagramLines.join("\n");
						idx += 1;
					}
					while (idx < lines.length && !lines[idx].trim()) {
						idx += 1;
					}
					if (idx < lines.length && lines[idx].startsWith("###")) {
						idx += 1;
					}
					while (idx < lines.length && !lines[idx].trim()) {
						idx += 1;
					}
					const tableLines = [];
					while (idx < lines.length && lines[idx].startsWith("|")) {
						tableLines.push(lines[idx]);
						idx += 1;
					}
					sections.push({
						title: sectionTitle,
						diagram: diagramDef,
						tableMarkdown: tableLines.join("\n"),
					});
					continue;
				}
				idx += 1;
			}

			return { title, sections, footer };
		}

		function escapeHtml(str) {
			return str
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;")
				.replace(/"/g, "&quot;")
				.replace(/'/g, "&#39;");
		}

		function tableMarkdownToHtml(markdown) {
			const rows = markdown.split(/\r?\n/).filter(Boolean);
			if (!rows.length) {
				return "";
			}
			const bodyRows = rows.filter((row) => !/^\|\s*-+/.test(row));
			const htmlRows = bodyRows.map((row, idx) => {
				const cells = row.split("|").slice(1, -1).map((cell, cellIdx) => {
					const tag = idx === 0 ? "th" : "td";
					return `<${tag}>${escapeHtml(cell.trim())}</${tag}>`;
				}).join("");
				return `<tr>${cells}</tr>`;
			});
			return `<table>${htmlRows.join("")}</table>`;
		}

		async function renderAllDiagrams() {
			for (const [elementId, info] of diagramDefinitions.entries()) {
				const target = document.getElementById(elementId);
				if (!target || !info?.definition) {
					continue;
				}
				const { svg } = await mermaid.render(`diagram_${elementId}_${Date.now()}`, info.definition, undefined, { theme: "neutral" });
				target.innerHTML = svg;
			}
		}

		async function downloadAllDiagramImages() {
			const entries = Array.from(diagramDefinitions.entries());
			for (let idx = 0; idx < entries.length; idx += 1) {
				const [elementId, info] = entries[idx];
				const svgMarkup = extractSvgMarkup(elementId);
				if (!svgMarkup) {
					continue;
				}
				const pngBlob = await svgMarkupToPngBlob(svgMarkup);
				const filename = `${slugify(diagramTitle.textContent || "repertoire")}_${slugify(info?.title || `section_${idx + 1}`)}.png`;
				triggerFileDownloadFromBlob(pngBlob, filename);
			}
		}

		function extractSvgMarkup(elementId) {
			const root = document.getElementById(elementId);
			const svg = root?.querySelector("svg");
			if (!svg) {
				return "";
			}
			try {
				return svgSerializer.serializeToString(svg);
			} catch (err) {
				console.error("Failed to serialize SVG", err);
				return svg.outerHTML || "";
			}
		}

		async function svgMarkupToPngBlob(svgMarkup) {
			const viewBoxMatch = svgMarkup.match(/viewBox="([\d.\s-]+)"/);
			const viewBox = viewBoxMatch ? viewBoxMatch[1].trim().split(/\s+/).map(Number) : null;
			const img = await loadImage(svgMarkup);
			const baseWidth = viewBox ? viewBox[2] : (img.naturalWidth || img.width || 1);
			const baseHeight = viewBox ? viewBox[3] : (img.naturalHeight || img.height || 1);
			const canvas = document.createElement("canvas");
			canvas.width = Math.max(1, Math.round(baseWidth * IMAGE_EXPORT_SCALE));
			canvas.height = Math.max(1, Math.round(baseHeight * IMAGE_EXPORT_SCALE));
			const ctx = canvas.getContext("2d");
			if (ctx) {
				ctx.fillStyle = getCanvasBackgroundColor();
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.scale(IMAGE_EXPORT_SCALE, IMAGE_EXPORT_SCALE);
				ctx.drawImage(img, 0, 0, baseWidth, baseHeight);
			}
			return await new Promise((resolve, reject) => {
				canvas.toBlob((blob) => {
					if (blob) {
						resolve(blob);
					} else {
						reject(new Error("Could not export canvas"));
					}
				}, "image/png");
			});
		}

		function loadImage(svgMarkup) {
			return new Promise((resolve, reject) => {
				const img = new Image();
				img.decoding = "async";
				img.onload = () => resolve(img);
				img.onerror = (event) => {
					console.error("SVG rasterization failed", event);
					reject(new Error("Could not load SVG image"));
				};
				img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgMarkup);
			});
		}

		function triggerFileDownloadFromBlob(blob, filename) {
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			link.href = url;
			link.download = filename;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			URL.revokeObjectURL(url);
		}

		function slugify(value) {
			return (value || "")
				.toString()
				.toLowerCase()
				.replace(/[^a-z0-9]+/g, "_")
				.replace(/^_+|_+$/g, "")
				|| "diagram";
		}

		function applyDiagramTheme(theme) {
			const normalizedTheme = theme === DiagramThemes.LIGHT ? DiagramThemes.LIGHT : DiagramThemes.DARK;
			currentDiagramTheme = normalizedTheme;
			document.body.dataset.diagramTheme = normalizedTheme;
			if (diagramThemeBtn) {
				diagramThemeBtn.textContent = normalizedTheme === DiagramThemes.LIGHT
					? "Dark theme ◐"
					: "Light theme ☀";
			}
		}

		function getCanvasBackgroundColor() {
			const host = document.body || document.documentElement;
			const styles = getComputedStyle(host);
			const value = styles.getPropertyValue("--canvas-bg").trim();
			return value || "#ffffff";
		}

		function applyDiagramThemeToMarkdown(markdown, theme) {
			if (!markdown) {
				return markdown;
			}
			const initLine = buildMermaidInitDirective(theme);
			return markdown.replace(/```mermaid\s*\n([\s\S]*?)```/g, (match, inner) => {
				const sanitized = inner
					.replace(/^\s*%%\{init:[\s\S]*?%%\s*/i, "")
					.replace(/^\n+/, "");
				const body = sanitized.replace(/\s+$/, "");
				const newline = body.endsWith("\n") ? "" : "\n";
				return "```mermaid\n" + initLine + "\n" + body + newline + "```\n";
			});
		}

		function buildMermaidInitDirective(theme) {
			const config = DiagramThemeConfig[theme] || DiagramThemeConfig[DiagramThemes.DARK];
			const payload = {
				theme: "neutral",
				themeVariables: {
					background: config.background,
				},
			};
			return `%%{init: ${JSON.stringify(payload)}}%%`;
		}
	</script>
</body>

</html>
