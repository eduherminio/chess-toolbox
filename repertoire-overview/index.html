<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>Repertoire visualizer</title>
	<link rel="stylesheet" href="../tools-shared.css" />
</head>

<body>
	<main class="app-shell">
		<section class="hero">
			<h1>Repertoire visualizer</h1>
			<p>Get an overview of your repertoire by uploading a folder with multiple PGN files.</p>
		</section>

		<section class="panel">
			<p id="status" class="status-line">Initializing Python and installing python-chess…</p>
			<div class="file-input-helper">
				<input type="file" id="pgn-folder" accept=".pgn" webkitdirectory multiple class="hidden" />
				<button id="folder-picker" class="primary-btn" disabled>Choose PGN folder</button>
			</div>

			<h2 id="options-heading" class="options-heading hidden">Diagram options</h2>
			<div id="options" class="controls-grid hidden">
				<div class="control-item">
					<label for="side-select">Repertoire side</label>
					<select id="side-select">
						<option value="auto" selected>Auto (detect)</option>
						<option value="white">White</option>
						<option value="black">Black</option>
					</select>
				</div>
				<div class="control-item">
					<label for="max-ply">Max ply depth</label>
					<input type="number" id="max-ply" min="0" value="4" />
				</div>
				<div class="control-item">
					<span class="checkbox-label">
						<input type="checkbox" id="piece-symbols" checked />
						Show chess piece symbols
					</span>
				</div>
			</div>
		</section>

		<section class="panel">
			<div class="panel-heading">
				<h2 id="diagram-title" class="hidden"></h2>
				<button id="download-btn" class="ghost-btn hidden" disabled>Download overview ⭳</button>
			</div>
			<div id="sections-container" class="sections-stack"></div>
			<div id="legend" class="legend-block"></div>
		</section>

		<footer>
			Powered by <a href="https://github.com/eduherminio/chess-toolbox" target="_blank" rel="noopener noreferrer">eduherminio/chess-toolbox</a>
			· Runs entirely in your browser
		</footer>
	</main>

	<!-- Pyodide -->
	<script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>

	<!-- Mermaid -->
	<script type="module">
		import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
		mermaid.initialize({ startOnLoad: false, theme: "neutral" });

		let pyodide;
		const folderInput = document.getElementById("pgn-folder");
		const folderPicker = document.getElementById("folder-picker");
		const optionsContainer = document.getElementById("options");
		const optionsHeading = document.getElementById("options-heading");
		const sideSelect = document.getElementById("side-select");
		const pieceSymbolsInput = document.getElementById("piece-symbols");
		const maxPlyInput = document.getElementById("max-ply");
		const downloadBtn = document.getElementById("download-btn");
		const diagramTitle = document.getElementById("diagram-title");
		const sectionsContainer = document.getElementById("sections-container");
		const legendDiv = document.getElementById("legend");
		const statusEl = document.getElementById("status");
		const UPLOAD_BASE = "/tmp/repertoire_uploads";
		const diagramDefinitions = new Map();
		const textEncoder = new TextEncoder();
		const textDecoder = new TextDecoder("utf-8");
		let lastMarkdown = "";
		let currentDownloadName = "PGN_variations_overview.md";

		folderInput.value = "";

		function showUploadControls() {
			folderPicker.disabled = false;
			if (optionsHeading) {
				optionsHeading.classList.remove("hidden");
			}
			optionsContainer.classList.remove("hidden");
		}

		async function initPython() {
			pyodide = await loadPyodide({ fullStdLib: false });

			statusEl.textContent = "Installing python-chess…";
			await pyodide.loadPackage("micropip");
			await pyodide.runPythonAsync(`
				import micropip
				await micropip.install("chess")
			`);

			statusEl.textContent = "Loading repertoire overview logic…";

			const commonCode = await fetch("../scripts/common.py").then(r => r.text());
			await pyodide.FS.writeFile("common.py", commonCode);

			const overviewCode = await fetch("../scripts/repertoire_overview.py").then(r => r.text());
			await pyodide.FS.writeFile("repertoire_overview.py", overviewCode);

			pyodide.runPython("from repertoire_overview import main");

			statusEl.textContent = "Ready. Pick some PGN files from your repertoire.";
			showUploadControls();
		}

		initPython();

		folderPicker.addEventListener("click", () => {
			folderInput.click();
		});

		folderInput.addEventListener("change", async (event) => {
			const files = Array.from(event.target.files || []);
			const pgnFiles = files.filter((file) => file.name.toLowerCase().endsWith(".pgn"));

			if (!pgnFiles.length) {
				statusEl.textContent = "Select a folder that contains at least one .pgn file. If you're using Firefox, please try another browser";
				folderInput.value = "";
				return;
			}

			downloadBtn.disabled = true;
			downloadBtn.classList.add("hidden");
			diagramTitle.classList.add("hidden");
			sectionsContainer.innerHTML = "";
			legendDiv.innerHTML = "";
			statusEl.textContent = "Copying PGNs into the embedded filesystem…";

			try {
				const stagingInfo = await stageFilesInPyodide(pgnFiles);
				const sidePreference = sideSelect.value;
				const usePieceSymbols = pieceSymbolsInput.checked;
				const maxPlyValue = parseMaxPly(maxPlyInput.value);
				currentDownloadName = deriveMarkdownName(stagingInfo.displayName);

				statusEl.textContent = "Inferring repertoire overview…";
				const outputPath = `${stagingInfo.rootPath}/PGN_variations_overview.md`;
				const args = buildCliArgs(
					stagingInfo.rootPath,
					outputPath,
					sidePreference,
					maxPlyValue,
					usePieceSymbols,
				);
				const exitCode = await pyodide.runPythonAsync(`
from repertoire_overview import main
main(argv=${JSON.stringify(args)})
				`);

				if (exitCode !== 0) {
					throw new Error(`Python exited with code ${exitCode}`);
				}

				const markdownData = pyodide.FS.readFile(outputPath);
				const markdown = typeof markdownData === "string" ? markdownData : textDecoder.decode(markdownData);
				lastMarkdown = markdown;
				renderOverview(markdown, stagingInfo.displayName);
				statusEl.textContent = "Done.";
				downloadBtn.disabled = false;
				downloadBtn.classList.remove("hidden");
			} catch (err) {
				console.error(err);
				statusEl.textContent = `Something went wrong: ${err.message}`;
			} finally {
				folderInput.value = "";
			}
		});

		downloadBtn.addEventListener("click", () => {
			if (!lastMarkdown) {
				return;
			}
			const blob = new Blob([lastMarkdown], { type: "text/markdown" });
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			link.href = url;
			link.download = currentDownloadName;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			URL.revokeObjectURL(url);
		});

		async function stageFilesInPyodide(files) {
			const sessionDir = `${UPLOAD_BASE}/session_${Date.now()}`;
			try {
				pyodide.FS.mkdirTree(sessionDir);
			} catch (err) {
				if (err.code !== "EEXIST") {
					throw err;
				}
			}

			let topLevelFolder = null;
			let written = 0;
			for (const file of files) {
				const relativeParts = normalizeRelativePath(file);
				if (!relativeParts.length) {
					continue;
				}
				if (!topLevelFolder) {
					topLevelFolder = relativeParts[0];
				}
				const filePath = `${sessionDir}/${relativeParts.join("/")}`;
				const dirPath = filePath.slice(0, filePath.lastIndexOf("/"));
				if (dirPath) {
					pyodide.FS.mkdirTree(dirPath);
				}
				const content = await file.text();
				const encoded = textEncoder.encode(content);
				pyodide.FS.writeFile(filePath, encoded);
				written += 1;
			}

			if (!written) {
				throw new Error("No PGN files could be copied");
			}

			const rootPath = topLevelFolder ? `${sessionDir}/${topLevelFolder}` : sessionDir;
			const displayName = topLevelFolder || "repertoire";
			return { rootPath, displayName };
		}

		function normalizeRelativePath(file) {
			const relative = file.webkitRelativePath && file.webkitRelativePath.length > 0
				? file.webkitRelativePath
				: file.name;
			return relative.split("/").filter(Boolean);
		}

		function buildCliArgs(rootPath, outputPath, side, maxPly, pieceSymbols) {
			const args = ["--pgn-root", rootPath, "--output", outputPath, "--side", side];
			if (typeof maxPly === "number" && Number.isFinite(maxPly) && maxPly >= 0) {
				args.push("--max-ply", String(maxPly));
			}
			if (pieceSymbols) {
				args.push("--piece-symbols");
			}
			return args;
		}

		function parseMaxPly(value) {
			const parsed = Number.parseInt(String(value), 10);
			if (Number.isNaN(parsed) || parsed < 0) {
				return 4;
			}
			return parsed;
		}

		function deriveMarkdownName(folderName) {
			const safe = (folderName || "overview").trim() || "overview";
			return `${safe}_PGN_variations_overview.md`;
		}

		function renderOverview(markdown, folderLabel) {
			const parsed = parseOverviewMarkdown(markdown);
			diagramTitle.textContent = parsed.title || `Repertoire overview (${folderLabel})`;
			diagramTitle.classList.remove("hidden");
			sectionsContainer.innerHTML = "";
			diagramDefinitions.clear();

			parsed.sections.forEach((section, idx) => {
				const sectionEl = document.createElement("section");
				sectionEl.className = "section-card";

				const heading = document.createElement("h3");
				heading.textContent = section.title;
				sectionEl.appendChild(heading);

				const diagramWrapper = document.createElement("div");
				diagramWrapper.className = "diagram-wrapper";
				const pre = document.createElement("pre");
				pre.className = "mermaid";
				pre.id = `diagram-section-${idx}`;
				diagramWrapper.appendChild(pre);
				sectionEl.appendChild(diagramWrapper);
				diagramDefinitions.set(pre.id, section.diagram);

				if (section.tableMarkdown) {
					const tableHeading = document.createElement("h4");
					tableHeading.textContent = "Terminal references";
					sectionEl.appendChild(tableHeading);
					const tableWrapper = document.createElement("div");
					tableWrapper.innerHTML = tableMarkdownToHtml(section.tableMarkdown);
					sectionEl.appendChild(tableWrapper);
				}

				sectionsContainer.appendChild(sectionEl);
			});

			legendDiv.innerHTML = parsed.footer ? `<p>${escapeHtml(parsed.footer)}</p>` : "";
			void renderAllDiagrams();
		}

		function parseOverviewMarkdown(markdown) {
			const lines = markdown.split(/\r?\n/);
			const sections = [];
			let title = "";
			let idx = 0;
			let footer = "";

			while (idx < lines.length) {
				const line = lines[idx];
				if (!title && line.startsWith("# ")) {
					title = line.slice(2).trim();
					idx += 1;
					continue;
				}
				if (line.startsWith("> ")) {
					footer = line.replace(/^>\s*/, "").trim();
				}
				if (line.startsWith("## ")) {
					const sectionTitle = line.slice(3).trim();
					idx += 1;
					while (idx < lines.length && !lines[idx].trim()) {
						idx += 1;
					}
					let diagramDef = "";
					if (lines[idx] === "```mermaid") {
						idx += 1;
						const diagramLines = [];
						while (idx < lines.length && lines[idx] !== "```") {
							diagramLines.push(lines[idx]);
							idx += 1;
						}
						diagramDef = diagramLines.join("\n");
						idx += 1;
					}
					while (idx < lines.length && !lines[idx].trim()) {
						idx += 1;
					}
					if (idx < lines.length && lines[idx].startsWith("###")) {
						idx += 1;
					}
					while (idx < lines.length && !lines[idx].trim()) {
						idx += 1;
					}
					const tableLines = [];
					while (idx < lines.length && lines[idx].startsWith("|")) {
						tableLines.push(lines[idx]);
						idx += 1;
					}
					sections.push({
						title: sectionTitle,
						diagram: diagramDef,
						tableMarkdown: tableLines.join("\n"),
					});
					continue;
				}
				idx += 1;
			}

			return { title, sections, footer };
		}

		function escapeHtml(str) {
			return str
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;")
				.replace(/"/g, "&quot;")
				.replace(/'/g, "&#39;");
		}

		function tableMarkdownToHtml(markdown) {
			const rows = markdown.split(/\r?\n/).filter(Boolean);
			if (!rows.length) {
				return "";
			}
			const bodyRows = rows.filter((row) => !/^\|\s*-+/.test(row));
			const htmlRows = bodyRows.map((row, idx) => {
				const cells = row.split("|").slice(1, -1).map((cell, cellIdx) => {
					const tag = idx === 0 ? "th" : "td";
					return `<${tag}>${escapeHtml(cell.trim())}</${tag}>`;
				}).join("");
				return `<tr>${cells}</tr>`;
			});
			return `<table>${htmlRows.join("")}</table>`;
		}

		async function renderAllDiagrams() {
			for (const [elementId, definition] of diagramDefinitions.entries()) {
				const target = document.getElementById(elementId);
				if (!target || !definition) {
					continue;
				}
				const { svg } = await mermaid.render(`diagram_${elementId}_${Date.now()}`, definition, undefined, { theme: "neutral" });
				target.innerHTML = svg;
			}
		}
	</script>
</body>

</html>
